package gen

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"

	"github.com/earlgray283/fixgen/internal/templates"
	"golang.org/x/tools/imports"
)

type File struct {
	Name    string
	Content []byte
}

type Generator interface {
	Generate() ([]*File, error)
	GenPackageInfo() *GenPackageInfo
	IsExperimental() bool
}

type GenPackageInfo struct {
	PackagePath  string // e.g. github.com/earlgray283/pj-todo/models
	PackageAlias string // e.g. yo_gen
}

type Option struct {
	PackageName string // default: "fixture"
	DestDir     string // default: "."
	WorkDir     string // default: "."
}

func DefaultOption() *Option {
	return &Option{
		PackageName: "fixture",
		DestDir:     ".",
		WorkDir:     ".",
	}
}

type OptionFunc func(*Option)

func (o *Option) ApplyOptionFuncs(optFuncs ...OptionFunc) {
	for _, optFunc := range optFuncs {
		optFunc(o)
	}
}

func WithPackageName(packageName string) OptionFunc {
	return func(o *Option) {
		o.PackageName = packageName
	}
}

func WithWorkDir(workDir string) OptionFunc {
	return func(o *Option) {
		o.WorkDir = workDir
	}
}

const commentGeneratedFixgen = "// Code generated by fixgen, DO NOT EDIT."

func GenerateWithFormat[G Generator](g G, packageName string) ([]*File, error) {
	files, err := g.Generate()
	if err != nil {
		return nil, fmt.Errorf("failed to generator.Generate: %+w", err)
	}
	commonFile, err := generateCommonFile()
	if err != nil {
		return nil, err
	}
	files = append(files, commonFile)

	genPkgInfo := g.GenPackageInfo()
	header, err := ExecuteTemplate(templates.TmplHeaderFile, map[string]string{
		"PackageName": packageName,
		"GenPkgAlias": genPkgInfo.PackageAlias,
		"GenPkgPath":  genPkgInfo.PackagePath,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to ExecuteTemplate: %+w", err)
	}

	for _, f := range files {
		f.Content = append(header, f.Content...)
		content, err := Format(f.Content)
		if err != nil {
			return nil, fmt.Errorf("failed to Format: %+w", err)
		}
		f.Content = content
	}

	return files, nil
}

func generateCommonFile() (*File, error) {
	content, err := ExecuteTemplate(templates.TmplCommonFile, nil)
	if err != nil {
		return nil, err
	}
	return &File{Name: "common", Content: content}, nil
}

func Format(content []byte) ([]byte, error) {
	formated, err := imports.Process("", content, &imports.Options{})
	if err != nil {
		return nil, fmt.Errorf("failed to apply format: %w\n%s", err, content)
	}
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "%s\n\n", commentGeneratedFixgen)
	buf.Write(formated)
	return buf.Bytes(), nil
}

func SaveFile(name string, content []byte) error {
	f, err := os.Create(name)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := io.Copy(f, bytes.NewReader(content)); err != nil {
		return err
	}

	return nil
}

func CreateDirIfNotExists(p string) error {
	if _, err := os.Stat(p); err != nil {
		if !errors.Is(err, os.ErrNotExist) {
			return err
		}
		if err := os.MkdirAll(p, 0755); err != nil {
			return err
		}
	}
	return nil
}
