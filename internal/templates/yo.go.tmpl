func Create{{.TableName}}({{ if .UseContext}}ctx context.Context,{{ end }} t *testing.T, db *spanner.Client, m *yo_gen.{{.TableName}}, opts ...func(*yo_gen.{{ .TableName }})) *yo_gen.{{.TableName}} {
  t.Helper()

  tbl := &yo_gen.{{.TableName}} {
  {{ range $i, $f := .Fields -}}
    {{ if $f.IsSpannerNullType }} // {{ $f.Name }} is nullable
    {{ else if $f.Type.IsSlice }} // {{ $f.Name }} is slice
    {{ else if not $f.DefaultValue -}} // {{ $f.Name }} does not have a default value,
    {{ else }} {{ $f.Name }}: {{ $f.DefaultValue }}, {{ if $f.IsOverwritten }} // {{ $f.Name }} is overwritten {{ end }}
    {{ end }}
  {{- end -}}
  }

  {{ range $i, $f := .Fields -}}
  if
    {{- if $f.IsSpannerNullType }} !m.{{ $f.Name }}.IsNull()
    {{- else if $f.Type.IsSlice }} len(m.{{ $f.Name }}) > 0
    {{- else }} isModified(m.{{ $f.Name }})
    {{- end -}} {
    {{ if $f.AllowCommitTimestamp -}} t.Fatal("spanner.CommitTimestamp should be used")
    {{- else -}} tbl.{{ $f.Name }} = m.{{ $f.Name }}
    {{- end }}
  }
  {{ end -}}
  for _, opt := range opts {
    opt(tbl)
  }

  _, err := db.ReadWriteTransaction({{ if .UseContext }}ctx{{ else }}context.Background(){{end}}, func(ctx context.Context, tx *spanner.ReadWriteTransaction) error {
    return tx.BufferWrite([]*spanner.Mutation{tbl.Insert(ctx)})
  })
  if err != nil {
    t.Fatal(err)
  }

  return tbl
}

